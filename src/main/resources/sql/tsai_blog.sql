/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50724
Source Host           : localhost:3306
Source Database       : tsai_blog

Target Server Type    : MYSQL
Target Server Version : 50724
File Encoding         : 65001

Date: 2019-01-19 23:50:06
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog` (
  `blog_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `blog_title` varchar(255) CHARACTER SET utf8 NOT NULL,
  `blog_summary` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `blog_keyword` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `blog_images` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `blog_clicknum` int(11) NOT NULL DEFAULT '0',
  `blog_content` longtext CHARACTER SET utf8,
  `blog_add_time` datetime DEFAULT NULL,
  `blog_update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`blog_id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES ('1', 'Spring技术内幕：设计理念和整体架构概述', 'spring技术在中国很流行趋势', 'spring', 'http://pknhrkp8l.bkt.clouddn.com/login.jpg', '0', '<p>程序员都很崇拜技术大神，很大一部分是因为他们发现和解决问题的能力，特别是线上出现紧急问题时，总是能够快速定位和解决。</p>\r\n<p>一方面，他们有深厚的技术基础，对应用的技术知其所以然，另一方面，在采坑的过程中不断总结，积累了很多经验。</p>\r\n<p>相信大家都使用过Spring，有些人了解它的核心：IOC和AOP，但只是了解它们的基本概念、使用了反射和动态代理，关于如何管理对象、代理的具体实现了解的比较浅。</p>\r\n<p>有些人使用Spring MVC，使用Spring集成数据库、事务、消息队列以简化操作，但对集成的具体设计思路和实现了解的也比较浅。</p>\r\n<p>我也这一块也比较菜，所以，后面的一段时间会梳理和总结Spring相关的技术原理，以「Spring技术内幕：深入解析Spring架构与设计原理」书籍为核心，结合自己的使用经验和疑问，以及网络上大牛的文章，来补足自己这方面的缺失。</p>\r\n<blockquote>\r\n<p>这本书作者是计文柯，以Spring源代码为依托，从宏观上揭示了Spring的设计思路和架构思想，从微观上剖析了Spring各功能模块的实现原理和运行机制。一方面希望读者能通过深入了解Spring的底层机制来更好地解决实际开发中遇到的各种难题，另一方面是希望读者能吸收Spring设计和实现中的优秀方法和思想。</p>\r\n</blockquote>\r\n<p>全书共三部分，分别阐述了Spring的核心、组件和应用。第一部分详细分析了IOC容器和AOP实现，第二部分阐述了基于Spring IOC容器和AOP的Java EE组件在Spring中的实现，第三部分讲述了一些基于Spring的典型应用的实现。</p>\r\n<p>本篇先对设计理念和整体架构做个概述，从整体上看看Spring的设计目标和架构，通过本篇，你会了解到：</p>\r\n<ul>\r\n<li>Spring的设计目标</li>\r\n<li>Spring的整体架构</li>\r\n<li>Spring的各个子项目介绍</li>\r\n</ul>\r\n\r\n<h3 class=\"heading\" data-id=\"heading-0\">设计目标</h3>\r\n<p>简单来说，Spring的设计目标是为我们提供一个一站式的轻量级应用开发平台，抽象了应用开发中遇到的共性问题。</p>\r\n<p>作为平台，它考虑到了企业应用资源的使用，比如数据的持久化、数据集成、事务处理、消息中间件、分布式式计算等高效可靠处理企业数据方法的技术抽象。</p>\r\n<p>轻量级是相对于传统J2EE而言的，传统的J2EE开发，需要依赖按照J2EE规范实现的J2EE应用服务器，设计和实现时，需要遵循一系列的接口标准，这种开发方式耦合性高，使应用在可测试性和部署上都有影响，对技术的理解和要求相对较高。</p>\r\n<p>使用Spring进行开发，对开发人员比较轻量，可以使用POJO和JavaBean的开发方式，使应用面向接口开发，充分支持了面向对象的设计方法。通过IOC容器减少了直接耦合，通过AOP以动态和非侵入的方式增加了服务的功能，为灵活选取不同的服务实现提供了基础，这也是Spring的核心。</p>\r\n<p>开发过程中的共性问题，Spring封装成了各种组件，而且Spring通过社区，形成了一个开放的生态系统，比如Spring Security就是来源于一个社区贡献Acegi.</p>\r\n<h3 class=\"heading\" data-id=\"heading-1\">整体架构</h3>\r\n<p>从总体来看，Spring分为3层，最底层是核心层，包括IOC、AOP等核心模块，中间层是封装的JavaEE服务、作为中间的驱动组件，最上层是各个应用。</p>\r\n<p>下图是Spring官网的一个架构图，介绍下其组成部分：</p>\r\n<p></p><figure><img alt=\"Spring Framework架构图\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/20/1637c9065ce420bd?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"720\" data-height=\"540\"><figcaption></figcaption></figure><p></p>\r\n<h4 class=\"heading\" data-id=\"heading-2\">核心容器</h4>\r\n<p>由spring-core、spring-beans、spring-context、spring-context-support和spring-expression模块组成：</p>\r\n<p>spring-core和spring-beans提供框架的基础部分，包括IOC功能，BeanFactory是一个复杂的工厂模式的实现，将配置和特定的依赖从实际程序逻辑中解耦。</p>\r\n<p>context模块建立在core和beans模块的基础上，增加了对国际化的支持、事件广播、资源加载和创建上下文，ApplicationContext是context模块的重点。</p>\r\n<p>spring-context-support提供对常见第三个库的支持，集成到spring上下文中，比如缓存(ehcache,guava)、通信(javamail)、调度(commonj,quartz)、模板引擎等(freemarker,velocity)。</p>\r\n<p>spring-expression模块提供了一个强大的表达式语言用来在运行时查询和操作对象图，这种语言支持对属性值、属性参数、方法调用、数组内容存储、集合和索引、逻辑和算数操作及命名变量，并且通过名称从spring的控制反转容器中取回对象。</p>\r\n<h4 class=\"heading\" data-id=\"heading-3\">AOP和服务器工具</h4>\r\n<p>spring-aop模块提供面向切面编程实现，单独的spring-aspects模块提供了aspectj的集成和适用。</p>\r\n<p>spring-instrument提供一些类级的工具支持和ClassLoader级的实现，用于服务器。spring-instrument-tomcat针对tomcat的instrument实现。</p>\r\n<h4 class=\"heading\" data-id=\"heading-4\">消息组件</h4>\r\n<p>spring框架4包含了spring-messaging模块，从spring集成项目中抽象出来，比如Messge、MessageChannel、MessageHandler及其他用来提供基于消息的基础服务。</p>\r\n<h4 class=\"heading\" data-id=\"heading-5\">数据访问/集成</h4>\r\n<p>数据访问和集成层由JDBC、ORM、OXM、JMS和事务模块组成。</p>\r\n<p>spring-jdbc模块提供了不需要编写冗长的JDBC代码和解析数据库厂商特有的错误代码的JDBC抽象出。</p>\r\n<p>spring-tx模块提供可编程和声明式事务管理。</p>\r\n<p>spring-orm模块提供了领先的对象关系映射API集成层，如JPA、Hibernate等。</p>\r\n<p>spring-oxm模块提供抽象层用于支持Object/XML maping的实现，如JAXB、XStream等。</p>\r\n<p>spring-jms模块包含生产和消费消息的功能，从Spring4.1开始提供集成spring-messaging模块。</p>\r\n<h4 class=\"heading\" data-id=\"heading-6\">Web</h4>\r\n<p>Web层包含spring-web、spirng-webmvc、spring-websocket和spring-webmvc-portlet模块组成。</p>\r\n<p>spring-web模块提供了基本的面向web开发的集成功能，例如多文件上传、使用servert listeners和web开发应用程序上下文初始化IOC容器。也包含HTTP客户端以及spring远程访问的支持的web相关部分。</p>\r\n<p>spring-webmvc包含spring的model-view-controller和REST web services 实现的Web应用程序。</p>\r\n<p>spring-webmvc-portlet模块提供了MVC模式的portlet实现，protlet与Servlet的最大区别是请求的处理分为action和render阶段，在一个请求中，action阶段只执行一次，但render阶段可能由于用户的浏览器操作而被执行多次。</p>\r\n<h4 class=\"heading\" data-id=\"heading-7\">测试</h4>\r\n<p>spring-test模块支持通过组合Junit或TestNG来进行单元测试和集成测试，提供了连续的加载ApplicationContext并且缓存这些上下文。</p>\r\n<h3 class=\"heading\" data-id=\"heading-8\">各个子项目介绍</h3>\r\n<p>从配置到安全，从web应用到大数据——无论您的应用程序需要什么样的基础设施，都有一个Spring项目来帮助您构建它，Spring是模块化的设计。</p>\r\n<h4 class=\"heading\" data-id=\"heading-9\">Spring Boot</h4>\r\n<p>简化新Spring应用的初始搭建以及开发过程，使用特定的方式进行配置，使开发人员不再需要定义样板化的配置，实现快速开发。</p>\r\n<h4 class=\"heading\" data-id=\"heading-10\">Spring Cloud</h4>\r\n<p>为分布式系统开发提供工具集，基于Spring Boot，为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话、集群状态管理等操作提供了一种简单的开发方式，其下有很多子项目：</p>\r\n<ul>\r\n<li>分布式/版本化配置：Spring Cloud Config</li>\r\n<li>服务注册和发现：Netflix Eureka 或者 Spring Cloud Eureka（对前者的二次封装）</li>\r\n<li>路由：Spring Cloud Zuul，基于 Netflix Zuul</li>\r\n<li>service - to - service调用：Spring Cloud Feign</li>\r\n<li>负载均衡：Spring Cloud Ribbon 基于 Netflix Ribbon 实现</li>\r\n<li>断路器：Spring Cloud Hystrix</li>\r\n<li>分布式消息传递：Spring Cloud Bus</li>\r\n</ul>\r\n<h4 class=\"heading\" data-id=\"heading-11\">Spring Cloud Data Flow</h4>\r\n<p>Data flow 是一个用于开发和执行大范围数据处理、批量运算、持续运算的统一编程模型和托管服务。</p>\r\n<p>Spring Cloud Data Flow 是基于原生云对Spring XD的重新设计，项目目标是简化大数据应用的开发。Spring XD的流处理和批处理模块的重构分别基于spring boot的stream和task/batch的微服务程序。这些程序原生的支持像 Apache YARN、Apache Mesos和Kubernetes等现代运行环境，都是自动部署单元。</p>\r\n<h4 class=\"heading\" data-id=\"heading-12\">Spring Data</h4>\r\n<p>数据访问模块，提供了对JDBC及ORM很好的支持，随着NOSQL和BigData的兴起，出现了越来越多的新技术，比如非关系型数据库、MapReduce框架，为了让spring开发者能更方便地使用这些新技术，通过Spring Data，开发者可以用Spring提供的相对一致的方式访问位于不同类型的数据存储中的数据。</p>\r\n<p></p><figure><img alt=\"Spring Data\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/20/1637c9065cd50d84?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"367\" data-height=\"281\"><figcaption></figcaption></figure><p></p>\r\n<h4 class=\"heading\" data-id=\"heading-13\">Spring Integration</h4>\r\n<p>在企业软件开发过程中，经常会遇到与外部系统集成，Spring Integration为Spring编程模型提供了一个支持企业集成模式的扩展，在应用程序中提供轻量级的消息机制，通过声明式的适配器与外部系统进行集成。</p>\r\n<p>Spring Integraton中有几个基本的概念：</p>\r\n<ul>\r\n<li>Message：带有元数据的Java对象；</li>\r\n<li>Channel：传递消息的管道；</li>\r\n<li>Message Endpoint：消息的处理端，在处理端可以对消息进行转换、路由、过滤、拆分、聚合等操作；</li>\r\n</ul>\r\n<p>还可以使用Channel Adapter，这是应用程序与外界交互的地方，输入是Inbound、输出则是Outbound，可选的连接类型有很多，比如AMQP、JDBC、Web Services、FTP、JMS、XMPP、多种NoSQL数据库等等。只需通过简单的配置文件就能将所有这些东西串联在一起，实现复杂的集成工作。</p>\r\n<h4 class=\"heading\" data-id=\"heading-14\">Spring Batch</h4>\r\n<p>简化及优化大量数据的批处理操作，支持事务、并发、流程、监控、纵向和横向扩展，提供统一的接口管理和任务管理。</p>\r\n<p>例如它提供了很多方法来读取大型的文件（比如1GB的CSV、XML文件），在数据库中加载或更新几万甚至几十万条记录，如果直接select出所有记录，以至于拖垮整个系统，而使用了Spring Batch，框架会帮助他每次捞取一部分记录进行分页，在更新时分批进行提交。</p>\r\n<h4 class=\"heading\" data-id=\"heading-15\">Spring Security</h4>\r\n<p>一款Spring的认证和安全工具。其前身是Acegi，目标是为Spring应用提供一个安全服务，比如用户认证、授权等。</p>\r\n<p>它使用Servlet规范中的Filter保护Web请求并限制URL级别的访问，还能够使用Spring AOP保护方法调用——借助于对象代理和使用通知，能够确保只有具备适当权限的用户才能访问安全保护的方法。</p>\r\n<p>它非常灵活，能够基于各种数据存储来认证用户。它内置了多种常见的用户存储场景，如内存、关系型数据库以及LDAP，还可以编写并插入自定义的用户存储实现。</p>\r\n<h4 class=\"heading\" data-id=\"heading-16\">Spring HATEOAS</h4>\r\n<p>先来理解HATEOAS：大家都听过过REST，它的定位为「分布式超媒体应用」的架构风格，文中提到了HATEOAS(Hypermedia as the engine of application state)的概念，超媒体即应用状态引擎，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\r\n<p>比如获取一篇文章，非HATEOAS的响应例子是：</p>\r\n<pre><code class=\"hljs http copyable\" lang=\"http\">GET /posts/1 HTTP/1.1\r\nConnection: keep-alive\r\nHost: blog.example.com\r\n{\r\n    \"id\" : 1,\r\n    \"body\" : \"My first blog post\",\r\n    \"postdate\" : \"2015-05-30T21:41:12.650Z\"\r\n}\r\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>而HATEOAS的响应例子是：</p>\r\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">{\r\n    <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-number\">1</span>,\r\n    <span class=\"hljs-string\">\"body\"</span> : <span class=\"hljs-string\">\"My first blog post\"</span>,\r\n    <span class=\"hljs-string\">\"postdate\"</span> : <span class=\"hljs-string\">\"2015-05-30T21:41:12.650Z\"</span>,\r\n    <span class=\"hljs-string\">\"links\"</span> : [\r\n        {\r\n            <span class=\"hljs-string\">\"rel\"</span> : <span class=\"hljs-string\">\"self\"</span>,\r\n            <span class=\"hljs-string\">\"href\"</span> : http:<span class=\"hljs-comment\">//blog.example.com/posts/1,</span>\r\n            <span class=\"hljs-string\">\"method\"</span> : <span class=\"hljs-string\">\"GET\"</span>\r\n        }\r\n    ] \r\n}\r\n\r\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>为了简化签入或获取超链接等操作，Spring HATEOAS提供了相关的支持。</p>\r\n<h4 class=\"heading\" data-id=\"heading-17\">Spring Rest DOCS</h4>\r\n<p>可以生成准确可读的RESTful Service文档，Spring 官方文档都是用Spring REST Docs生成的。</p>\r\n<p>基于单元测试生成文档片段，不会侵入到源码中，所以就不会使得源码变得越来越臃肿，支持markdown，修改一行配置代码即可支持生成 MarkDown 语法的文档片段。</p>\r\n<p>默认的，在构建的时候，会首先运行单元测试，便生成了文档片段，然后在打包时，通过添加 asciidoctor-maven-plugin 插件即可生成最终的文档，只要是规范的开发过程，文档都会随版本的每次发布而自动更新。</p>\r\n<h4 class=\"heading\" data-id=\"heading-18\">Spring Social</h4>\r\n<p>使用 Spring Social 的最大好处在于它已经提供了对主流社交网站的支持，只需要简单配置即可，对于一些不太常用的社交网站，也可以从社区中找到相应的组件。</p>\r\n<h4 class=\"heading\" data-id=\"heading-19\">Spring AMQP</h4>\r\n<p>基于Spring框架的AMQP消息解决方案，提供模板化的发送和接收消息的抽象层，提供基于消息驱动的POJO，使在Spring应用中使用AMQP消息服务器变得更为简单，SpringSource旗下的Rabbit MQ就是一个开源的基于AMQP的消息服务器。</p>\r\n<h4 class=\"heading\" data-id=\"heading-20\">Spring Web Flow</h4>\r\n<p>Spring Web Flow是Spring MVC 的扩展，它支持开发基于流程的应用程序。它将流程的定义与实现流程行为的类和视图分离开来，具有同时处理多个HTTP请求、管理会话状态、数据事务处理，支持AJAX来构建丰富的客户端体验，并且提供对JSF的支持。</p>\r\n<h4 class=\"heading\" data-id=\"heading-21\">Spring LDAP</h4>\r\n<p>Spring LDAP是一个用于操作LDAP的Java框架。它是基于Spring的JdbcTemplate模式，能够帮助开发人员简化操作。</p>\r\n<h4 class=\"heading\" data-id=\"heading-22\">Spring Session</h4>\r\n<p>Spring Session提供了一套创建和管理Servlet HttpSession的方案。Spring Session提供了集群Session功能，默认采用外置的Redis来存储Session数据，以此来解决Session共享的问题。</p>\r\n<h4 class=\"heading\" data-id=\"heading-23\">Spring Shell</h4>\r\n<p>Spring Shell提供交互式的Shell，可以让你使用简单的基于Spring的编程模型来开发命令。</p>\r\n<h4 class=\"heading\" data-id=\"heading-24\">Spring Kafka</h4>\r\n<p>spring for kafka对原生的kafka client consumer的封装与集成。</p>\r\n<h4 class=\"heading\" data-id=\"heading-25\">Spring Statemachine</h4>\r\n<p>它的主要功能是帮助开发者简化状态机的开发过程，让状态机结构更加层次化。</p>\r\n<h4 class=\"heading\" data-id=\"heading-26\">Spring IO Platform</h4>\r\n<p>可以认为是一个依赖维护平台，该平台将相关依赖汇聚到一起，针对每个依赖，都提供了一个版本号。</p>\r\n<p>主要是解决依赖版本冲突问题，在使用Spring的时候，经常会使用到第三方库，一般大家都是根据经验挑选一个版本号或挑选最新的，风向较大，很容易冲突。</p>\r\n<p>Spring IO Platform能很好地解决这些问题，我们在添加第三方依赖的时候，不需要写版本号，它能够自动帮我们挑选一个最优的版本。</p>\r\n<p><strong><font color=\"green\">欢迎扫描下方二维码，关注我的个人微信公众号，查看更多文章</font> ~</strong></p>\r\n<p></p><figure><img alt=\"情情说\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/17/1636c8ed3f3eac2c?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"258\" data-height=\"258\"><figcaption></figcaption></figure><p></p>', '2019-01-10 19:48:19', '2019-01-19 19:48:30');
INSERT INTO `t_blog` VALUES ('2', '字符串见闻', '区别很明显，字符串A和B在声明的时候就已经被赋值了，按道理来说，这个应该和之前的分析一致，这个结果应该是s和t是同一个对象。运行之后，果真，控制台窗口出现了“s等于t，它们是同一个对象”字样。', 'spring', 'http://pknhrkp8l.bkt.clouddn.com/login.jpg', '0', '<p>程序员都很崇拜技术大神，很大一部分是因为他们发现和解决问题的能力，特别是线上出现紧急问题时，总是能够快速定位和解决。</p>\r\n<p>一方面，他们有深厚的技术基础，对应用的技术知其所以然，另一方面，在采坑的过程中不断总结，积累了很多经验。</p>\r\n<p>相信大家都使用过Spring，有些人了解它的核心：IOC和AOP，但只是了解它们的基本概念、使用了反射和动态代理，关于如何管理对象、代理的具体实现了解的比较浅。</p>\r\n<p>有些人使用Spring MVC，使用Spring集成数据库、事务、消息队列以简化操作，但对集成的具体设计思路和实现了解的也比较浅。</p>\r\n<p>我也这一块也比较菜，所以，后面的一段时间会梳理和总结Spring相关的技术原理，以「Spring技术内幕：深入解析Spring架构与设计原理」书籍为核心，结合自己的使用经验和疑问，以及网络上大牛的文章，来补足自己这方面的缺失。</p>\r\n<blockquote>\r\n<p>这本书作者是计文柯，以Spring源代码为依托，从宏观上揭示了Spring的设计思路和架构思想，从微观上剖析了Spring各功能模块的实现原理和运行机制。一方面希望读者能通过深入了解Spring的底层机制来更好地解决实际开发中遇到的各种难题，另一方面是希望读者能吸收Spring设计和实现中的优秀方法和思想。</p>\r\n</blockquote>\r\n<p>全书共三部分，分别阐述了Spring的核心、组件和应用。第一部分详细分析了IOC容器和AOP实现，第二部分阐述了基于Spring IOC容器和AOP的Java EE组件在Spring中的实现，第三部分讲述了一些基于Spring的典型应用的实现。</p>\r\n<p>本篇先对设计理念和整体架构做个概述，从整体上看看Spring的设计目标和架构，通过本篇，你会了解到：</p>\r\n<ul>\r\n<li>Spring的设计目标</li>\r\n<li>Spring的整体架构</li>\r\n<li>Spring的各个子项目介绍</li>\r\n</ul>\r\n\r\n<h3 class=\"heading\" data-id=\"heading-0\">设计目标</h3>\r\n<p>简单来说，Spring的设计目标是为我们提供一个一站式的轻量级应用开发平台，抽象了应用开发中遇到的共性问题。</p>\r\n<p>作为平台，它考虑到了企业应用资源的使用，比如数据的持久化、数据集成、事务处理、消息中间件、分布式式计算等高效可靠处理企业数据方法的技术抽象。</p>\r\n<p>轻量级是相对于传统J2EE而言的，传统的J2EE开发，需要依赖按照J2EE规范实现的J2EE应用服务器，设计和实现时，需要遵循一系列的接口标准，这种开发方式耦合性高，使应用在可测试性和部署上都有影响，对技术的理解和要求相对较高。</p>\r\n<p>使用Spring进行开发，对开发人员比较轻量，可以使用POJO和JavaBean的开发方式，使应用面向接口开发，充分支持了面向对象的设计方法。通过IOC容器减少了直接耦合，通过AOP以动态和非侵入的方式增加了服务的功能，为灵活选取不同的服务实现提供了基础，这也是Spring的核心。</p>\r\n<p>开发过程中的共性问题，Spring封装成了各种组件，而且Spring通过社区，形成了一个开放的生态系统，比如Spring Security就是来源于一个社区贡献Acegi.</p>\r\n<h3 class=\"heading\" data-id=\"heading-1\">整体架构</h3>\r\n<p>从总体来看，Spring分为3层，最底层是核心层，包括IOC、AOP等核心模块，中间层是封装的JavaEE服务、作为中间的驱动组件，最上层是各个应用。</p>\r\n<p>下图是Spring官网的一个架构图，介绍下其组成部分：</p>\r\n<p></p><figure><img alt=\"Spring Framework架构图\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/20/1637c9065ce420bd?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"720\" data-height=\"540\"><figcaption></figcaption></figure><p></p>\r\n<h4 class=\"heading\" data-id=\"heading-2\">核心容器</h4>\r\n<p>由spring-core、spring-beans、spring-context、spring-context-support和spring-expression模块组成：</p>\r\n<p>spring-core和spring-beans提供框架的基础部分，包括IOC功能，BeanFactory是一个复杂的工厂模式的实现，将配置和特定的依赖从实际程序逻辑中解耦。</p>\r\n<p>context模块建立在core和beans模块的基础上，增加了对国际化的支持、事件广播、资源加载和创建上下文，ApplicationContext是context模块的重点。</p>\r\n<p>spring-context-support提供对常见第三个库的支持，集成到spring上下文中，比如缓存(ehcache,guava)、通信(javamail)、调度(commonj,quartz)、模板引擎等(freemarker,velocity)。</p>\r\n<p>spring-expression模块提供了一个强大的表达式语言用来在运行时查询和操作对象图，这种语言支持对属性值、属性参数、方法调用、数组内容存储、集合和索引、逻辑和算数操作及命名变量，并且通过名称从spring的控制反转容器中取回对象。</p>\r\n<h4 class=\"heading\" data-id=\"heading-3\">AOP和服务器工具</h4>\r\n<p>spring-aop模块提供面向切面编程实现，单独的spring-aspects模块提供了aspectj的集成和适用。</p>\r\n<p>spring-instrument提供一些类级的工具支持和ClassLoader级的实现，用于服务器。spring-instrument-tomcat针对tomcat的instrument实现。</p>\r\n<h4 class=\"heading\" data-id=\"heading-4\">消息组件</h4>\r\n<p>spring框架4包含了spring-messaging模块，从spring集成项目中抽象出来，比如Messge、MessageChannel、MessageHandler及其他用来提供基于消息的基础服务。</p>\r\n<h4 class=\"heading\" data-id=\"heading-5\">数据访问/集成</h4>\r\n<p>数据访问和集成层由JDBC、ORM、OXM、JMS和事务模块组成。</p>\r\n<p>spring-jdbc模块提供了不需要编写冗长的JDBC代码和解析数据库厂商特有的错误代码的JDBC抽象出。</p>\r\n<p>spring-tx模块提供可编程和声明式事务管理。</p>\r\n<p>spring-orm模块提供了领先的对象关系映射API集成层，如JPA、Hibernate等。</p>\r\n<p>spring-oxm模块提供抽象层用于支持Object/XML maping的实现，如JAXB、XStream等。</p>\r\n<p>spring-jms模块包含生产和消费消息的功能，从Spring4.1开始提供集成spring-messaging模块。</p>\r\n<h4 class=\"heading\" data-id=\"heading-6\">Web</h4>\r\n<p>Web层包含spring-web、spirng-webmvc、spring-websocket和spring-webmvc-portlet模块组成。</p>\r\n<p>spring-web模块提供了基本的面向web开发的集成功能，例如多文件上传、使用servert listeners和web开发应用程序上下文初始化IOC容器。也包含HTTP客户端以及spring远程访问的支持的web相关部分。</p>\r\n<p>spring-webmvc包含spring的model-view-controller和REST web services 实现的Web应用程序。</p>\r\n<p>spring-webmvc-portlet模块提供了MVC模式的portlet实现，protlet与Servlet的最大区别是请求的处理分为action和render阶段，在一个请求中，action阶段只执行一次，但render阶段可能由于用户的浏览器操作而被执行多次。</p>\r\n<h4 class=\"heading\" data-id=\"heading-7\">测试</h4>\r\n<p>spring-test模块支持通过组合Junit或TestNG来进行单元测试和集成测试，提供了连续的加载ApplicationContext并且缓存这些上下文。</p>\r\n<h3 class=\"heading\" data-id=\"heading-8\">各个子项目介绍</h3>\r\n<p>从配置到安全，从web应用到大数据——无论您的应用程序需要什么样的基础设施，都有一个Spring项目来帮助您构建它，Spring是模块化的设计。</p>\r\n<h4 class=\"heading\" data-id=\"heading-9\">Spring Boot</h4>\r\n<p>简化新Spring应用的初始搭建以及开发过程，使用特定的方式进行配置，使开发人员不再需要定义样板化的配置，实现快速开发。</p>\r\n<h4 class=\"heading\" data-id=\"heading-10\">Spring Cloud</h4>\r\n<p>为分布式系统开发提供工具集，基于Spring Boot，为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话、集群状态管理等操作提供了一种简单的开发方式，其下有很多子项目：</p>\r\n<ul>\r\n<li>分布式/版本化配置：Spring Cloud Config</li>\r\n<li>服务注册和发现：Netflix Eureka 或者 Spring Cloud Eureka（对前者的二次封装）</li>\r\n<li>路由：Spring Cloud Zuul，基于 Netflix Zuul</li>\r\n<li>service - to - service调用：Spring Cloud Feign</li>\r\n<li>负载均衡：Spring Cloud Ribbon 基于 Netflix Ribbon 实现</li>\r\n<li>断路器：Spring Cloud Hystrix</li>\r\n<li>分布式消息传递：Spring Cloud Bus</li>\r\n</ul>\r\n<h4 class=\"heading\" data-id=\"heading-11\">Spring Cloud Data Flow</h4>\r\n<p>Data flow 是一个用于开发和执行大范围数据处理、批量运算、持续运算的统一编程模型和托管服务。</p>\r\n<p>Spring Cloud Data Flow 是基于原生云对Spring XD的重新设计，项目目标是简化大数据应用的开发。Spring XD的流处理和批处理模块的重构分别基于spring boot的stream和task/batch的微服务程序。这些程序原生的支持像 Apache YARN、Apache Mesos和Kubernetes等现代运行环境，都是自动部署单元。</p>\r\n<h4 class=\"heading\" data-id=\"heading-12\">Spring Data</h4>\r\n<p>数据访问模块，提供了对JDBC及ORM很好的支持，随着NOSQL和BigData的兴起，出现了越来越多的新技术，比如非关系型数据库、MapReduce框架，为了让spring开发者能更方便地使用这些新技术，通过Spring Data，开发者可以用Spring提供的相对一致的方式访问位于不同类型的数据存储中的数据。</p>\r\n<p></p><figure><img alt=\"Spring Data\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/20/1637c9065cd50d84?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"367\" data-height=\"281\"><figcaption></figcaption></figure><p></p>\r\n<h4 class=\"heading\" data-id=\"heading-13\">Spring Integration</h4>\r\n<p>在企业软件开发过程中，经常会遇到与外部系统集成，Spring Integration为Spring编程模型提供了一个支持企业集成模式的扩展，在应用程序中提供轻量级的消息机制，通过声明式的适配器与外部系统进行集成。</p>\r\n<p>Spring Integraton中有几个基本的概念：</p>\r\n<ul>\r\n<li>Message：带有元数据的Java对象；</li>\r\n<li>Channel：传递消息的管道；</li>\r\n<li>Message Endpoint：消息的处理端，在处理端可以对消息进行转换、路由、过滤、拆分、聚合等操作；</li>\r\n</ul>\r\n<p>还可以使用Channel Adapter，这是应用程序与外界交互的地方，输入是Inbound、输出则是Outbound，可选的连接类型有很多，比如AMQP、JDBC、Web Services、FTP、JMS、XMPP、多种NoSQL数据库等等。只需通过简单的配置文件就能将所有这些东西串联在一起，实现复杂的集成工作。</p>\r\n<h4 class=\"heading\" data-id=\"heading-14\">Spring Batch</h4>\r\n<p>简化及优化大量数据的批处理操作，支持事务、并发、流程、监控、纵向和横向扩展，提供统一的接口管理和任务管理。</p>\r\n<p>例如它提供了很多方法来读取大型的文件（比如1GB的CSV、XML文件），在数据库中加载或更新几万甚至几十万条记录，如果直接select出所有记录，以至于拖垮整个系统，而使用了Spring Batch，框架会帮助他每次捞取一部分记录进行分页，在更新时分批进行提交。</p>\r\n<h4 class=\"heading\" data-id=\"heading-15\">Spring Security</h4>\r\n<p>一款Spring的认证和安全工具。其前身是Acegi，目标是为Spring应用提供一个安全服务，比如用户认证、授权等。</p>\r\n<p>它使用Servlet规范中的Filter保护Web请求并限制URL级别的访问，还能够使用Spring AOP保护方法调用——借助于对象代理和使用通知，能够确保只有具备适当权限的用户才能访问安全保护的方法。</p>\r\n<p>它非常灵活，能够基于各种数据存储来认证用户。它内置了多种常见的用户存储场景，如内存、关系型数据库以及LDAP，还可以编写并插入自定义的用户存储实现。</p>\r\n<h4 class=\"heading\" data-id=\"heading-16\">Spring HATEOAS</h4>\r\n<p>先来理解HATEOAS：大家都听过过REST，它的定位为「分布式超媒体应用」的架构风格，文中提到了HATEOAS(Hypermedia as the engine of application state)的概念，超媒体即应用状态引擎，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\r\n<p>比如获取一篇文章，非HATEOAS的响应例子是：</p>\r\n<pre><code class=\"hljs http copyable\" lang=\"http\">GET /posts/1 HTTP/1.1\r\nConnection: keep-alive\r\nHost: blog.example.com\r\n{\r\n    \"id\" : 1,\r\n    \"body\" : \"My first blog post\",\r\n    \"postdate\" : \"2015-05-30T21:41:12.650Z\"\r\n}\r\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>而HATEOAS的响应例子是：</p>\r\n<pre><code class=\"hljs javascript copyable\" lang=\"javascript\">{\r\n    <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-number\">1</span>,\r\n    <span class=\"hljs-string\">\"body\"</span> : <span class=\"hljs-string\">\"My first blog post\"</span>,\r\n    <span class=\"hljs-string\">\"postdate\"</span> : <span class=\"hljs-string\">\"2015-05-30T21:41:12.650Z\"</span>,\r\n    <span class=\"hljs-string\">\"links\"</span> : [\r\n        {\r\n            <span class=\"hljs-string\">\"rel\"</span> : <span class=\"hljs-string\">\"self\"</span>,\r\n            <span class=\"hljs-string\">\"href\"</span> : http:<span class=\"hljs-comment\">//blog.example.com/posts/1,</span>\r\n            <span class=\"hljs-string\">\"method\"</span> : <span class=\"hljs-string\">\"GET\"</span>\r\n        }\r\n    ] \r\n}\r\n\r\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>为了简化签入或获取超链接等操作，Spring HATEOAS提供了相关的支持。</p>\r\n<h4 class=\"heading\" data-id=\"heading-17\">Spring Rest DOCS</h4>\r\n<p>可以生成准确可读的RESTful Service文档，Spring 官方文档都是用Spring REST Docs生成的。</p>\r\n<p>基于单元测试生成文档片段，不会侵入到源码中，所以就不会使得源码变得越来越臃肿，支持markdown，修改一行配置代码即可支持生成 MarkDown 语法的文档片段。</p>\r\n<p>默认的，在构建的时候，会首先运行单元测试，便生成了文档片段，然后在打包时，通过添加 asciidoctor-maven-plugin 插件即可生成最终的文档，只要是规范的开发过程，文档都会随版本的每次发布而自动更新。</p>\r\n<h4 class=\"heading\" data-id=\"heading-18\">Spring Social</h4>\r\n<p>使用 Spring Social 的最大好处在于它已经提供了对主流社交网站的支持，只需要简单配置即可，对于一些不太常用的社交网站，也可以从社区中找到相应的组件。</p>\r\n<h4 class=\"heading\" data-id=\"heading-19\">Spring AMQP</h4>\r\n<p>基于Spring框架的AMQP消息解决方案，提供模板化的发送和接收消息的抽象层，提供基于消息驱动的POJO，使在Spring应用中使用AMQP消息服务器变得更为简单，SpringSource旗下的Rabbit MQ就是一个开源的基于AMQP的消息服务器。</p>\r\n<h4 class=\"heading\" data-id=\"heading-20\">Spring Web Flow</h4>\r\n<p>Spring Web Flow是Spring MVC 的扩展，它支持开发基于流程的应用程序。它将流程的定义与实现流程行为的类和视图分离开来，具有同时处理多个HTTP请求、管理会话状态、数据事务处理，支持AJAX来构建丰富的客户端体验，并且提供对JSF的支持。</p>\r\n<h4 class=\"heading\" data-id=\"heading-21\">Spring LDAP</h4>\r\n<p>Spring LDAP是一个用于操作LDAP的Java框架。它是基于Spring的JdbcTemplate模式，能够帮助开发人员简化操作。</p>\r\n<h4 class=\"heading\" data-id=\"heading-22\">Spring Session</h4>\r\n<p>Spring Session提供了一套创建和管理Servlet HttpSession的方案。Spring Session提供了集群Session功能，默认采用外置的Redis来存储Session数据，以此来解决Session共享的问题。</p>\r\n<h4 class=\"heading\" data-id=\"heading-23\">Spring Shell</h4>\r\n<p>Spring Shell提供交互式的Shell，可以让你使用简单的基于Spring的编程模型来开发命令。</p>\r\n<h4 class=\"heading\" data-id=\"heading-24\">Spring Kafka</h4>\r\n<p>spring for kafka对原生的kafka client consumer的封装与集成。</p>\r\n<h4 class=\"heading\" data-id=\"heading-25\">Spring Statemachine</h4>\r\n<p>它的主要功能是帮助开发者简化状态机的开发过程，让状态机结构更加层次化。</p>\r\n<h4 class=\"heading\" data-id=\"heading-26\">Spring IO Platform</h4>\r\n<p>可以认为是一个依赖维护平台，该平台将相关依赖汇聚到一起，针对每个依赖，都提供了一个版本号。</p>\r\n<p>主要是解决依赖版本冲突问题，在使用Spring的时候，经常会使用到第三方库，一般大家都是根据经验挑选一个版本号或挑选最新的，风向较大，很容易冲突。</p>\r\n<p>Spring IO Platform能很好地解决这些问题，我们在添加第三方依赖的时候，不需要写版本号，它能够自动帮我们挑选一个最优的版本。</p>\r\n<p><strong><font color=\"green\">欢迎扫描下方二维码，关注我的个人微信公众号，查看更多文章</font> ~</strong></p>\r\n<p></p><figure><img alt=\"情情说\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/5/17/1636c8ed3f3eac2c?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"258\" data-height=\"258\"><figcaption></figcaption></figure><p></p>', '2019-01-10 19:48:19', '2019-01-19 19:48:30');
INSERT INTO `t_blog` VALUES ('3', 'Java、JDBC与MySQL数据类型对照数据类型之间的转换', '前几天在设计数据库时偶然发现mysql还有tinyint 型的字段，百度之后知道了\r\n\r\nTINYINT ，字段类型，如果设置为UNSIGNED类型，只能存储从0到255的整数,不能用来储存负数\r\nTINYINT 型的字段如果不设置UNSIGNED类型,存储-128到127的整数。', 'spring', 'http://pknhrkp8l.bkt.clouddn.com/login.jpg', '0', '<p>前几天在设计数据库时偶然发现mysql还有<a href=\"https://link.jianshu.com?t=http://baike.baidu.com/link?url=v3gBOwKh6pQhQyaXFYT1QapMpsvgWfPZMQ27-rSmUZDGPrjepkAw8suOo4JERHEnZXJgAQIP_OKHtj-Ea2Pn1a\" target=\"_blank\" rel=\"nofollow\">tinyint</a> 型的字段，百度之后知道了</p>\r\n<blockquote>\r\n<p>TINYINT ，字段类型，如果设置为UNSIGNED类型，只能存储从0到255的整数,不能用来储存负数<br>\r\nTINYINT 型的字段如果不设置UNSIGNED类型,存储-128到127的整数。</p>\r\n</blockquote>\r\n<p>因此我发现用1个tinyint型数据只占用一个字节;一个INT型数据占用四个字节。这看起来似乎差别不大，但是在比较大的表中，字节数的增长是很快的。这个数据类型也确实能为我们节省一定存储空间。<br>\r\n看着不错我决定用它来存储成绩，感觉大小刚刚好，那么他在java中又对应什么类型呢？反正寒假在家除了敲代码也没有什么乐趣了<code>拍照摄影？外面雾霾大，在家吧</code>，索性把他们之间的关系理理。</p>\r\n<h3>官方的关系对应表</h3>\r\n<p>引自<a href=\"https://link.jianshu.com?t=https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-type-conversions.html\" target=\"_blank\" rel=\"nofollow\">mysql.com-- Java, JDBC and MySQL Types</a></p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:center\">MySQL类型名</th>\r\n<th style=\"text-align:center\">返回值 GetColumnClassName</th>\r\n<th style=\"text-align:center\">返回的Java类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:center\">BIT(1) (new in MySQL-5.0)</td>\r\n<td style=\"text-align:center\">BIT</td>\r\n<td style=\"text-align:center\">java.lang.Boolean</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">BIT( &gt; 1) (new in MySQL-5.0)</td>\r\n<td style=\"text-align:center\">BIT</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">TINYINT</td>\r\n<td style=\"text-align:center\">TINYINT</td>\r\n<td style=\"text-align:center\">java.lang.Boolean if the configuration property tinyInt1isBit is set to true (the default) and the storage size is 1, or java.lang.Integer if  not.</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">BOOL, BOOLEAN</td>\r\n<td style=\"text-align:center\">TINYINT</td>\r\n<td style=\"text-align:center\">See TINYINT, above as these are aliases for TINYINT(1), currently.</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">SMALLINT[(M)] [UNSIGNED]</td>\r\n<td style=\"text-align:center\">SMALLINT [UNSIGNED]</td>\r\n<td style=\"text-align:center\">java.lang.Integer (regardless of whether it is UNSIGNED or not)</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">MEDIUMINT[(M)] [UNSIGNED]</td>\r\n<td style=\"text-align:center\">MEDIUMINT [UNSIGNED]</td>\r\n<td style=\"text-align:center\">java.lang.Integer (regardless of whether it is UNSIGNED or not)</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">INT,INTEGER[(M)] [UNSIGNED]</td>\r\n<td style=\"text-align:center\">INTEGER [UNSIGNED]</td>\r\n<td style=\"text-align:center\">java.lang.Integer, if UNSIGNED java.lang.Long</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">BIGINT[(M)] [UNSIGNED]</td>\r\n<td style=\"text-align:center\">BIGINT [UNSIGNED]</td>\r\n<td style=\"text-align:center\">java.lang.Long, if UNSIGNED java.math.BigInteger</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">FLOAT[(M,D)]</td>\r\n<td style=\"text-align:center\">FLOAT</td>\r\n<td style=\"text-align:center\">java.lang.Float</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">DOUBLE[(M,B)]</td>\r\n<td style=\"text-align:center\">DOUBLE</td>\r\n<td style=\"text-align:center\">java.lang.Double</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">DECIMAL[(M[,D])]</td>\r\n<td style=\"text-align:center\">DECIMAL</td>\r\n<td style=\"text-align:center\">java.math.BigDecimal</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">DATE</td>\r\n<td style=\"text-align:center\">DATE</td>\r\n<td style=\"text-align:center\">java.sql.Date</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">DATETIME</td>\r\n<td style=\"text-align:center\">DATETIME</td>\r\n<td style=\"text-align:center\">java.sql.Timestamp</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">TIMESTAMP[(M)]</td>\r\n<td style=\"text-align:center\">TIMESTAMP</td>\r\n<td style=\"text-align:center\">java.sql.Timestamp</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">TIME</td>\r\n<td style=\"text-align:center\">TIME</td>\r\n<td style=\"text-align:center\">java.sql.Time</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">YEAR[(2/4)]</td>\r\n<td style=\"text-align:center\">YEAR</td>\r\n<td style=\"text-align:center\">If yearIsDateType configuration property is set to false, then the returned object type is java.sql.Short. If set to true (the default), then the returned object is of type java.sql.Datewith the date set to January 1st, at midnight.</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">CHAR(M)</td>\r\n<td style=\"text-align:center\">CHAR</td>\r\n<td style=\"text-align:center\">java.lang.String (unless the character set for the column is BINARY, then byte[] is returned.</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">VARCHAR(M) [BINARY]</td>\r\n<td style=\"text-align:center\">VARCHAR</td>\r\n<td style=\"text-align:center\">java.lang.String (unless the character set for the column is BINARY, then byte[] is returned.</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">BINARY(M)</td>\r\n<td style=\"text-align:center\">BINARY</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">VARBINARY(M)</td>\r\n<td style=\"text-align:center\">VARBINARY</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">TINYBLOB</td>\r\n<td style=\"text-align:center\">TINYBLOB</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">TINYTEXT</td>\r\n<td style=\"text-align:center\">VARCHAR</td>\r\n<td style=\"text-align:center\">java.lang.String</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">BLOB</td>\r\n<td style=\"text-align:center\">BLOB</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">TEXT</td>\r\n<td style=\"text-align:center\">VARCHAR</td>\r\n<td style=\"text-align:center\">java.lang.String</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">MEDIUMBLOB</td>\r\n<td style=\"text-align:center\">MEDIUMBLOB</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">MEDIUMTEXT</td>\r\n<td style=\"text-align:center\">VARCHAR</td>\r\n<td style=\"text-align:center\">java.lang.String</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">LONGBLOB</td>\r\n<td style=\"text-align:center\">LONGBLOB</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">LONGTEXT</td>\r\n<td style=\"text-align:center\">VARCHAR</td>\r\n<td style=\"text-align:center\">java.lang.String</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">ENUM(\'value1\',\'value2\',...)</td>\r\n<td style=\"text-align:center\">CHAR</td>\r\n<td style=\"text-align:center\">java.lang.String</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">SET(\'value1\',\'value2\',...)</td>\r\n<td style=\"text-align:center\">CHAR</td>\r\n<td style=\"text-align:center\">java.lang.String</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3>跨类型转换</h3>\r\n<p>下图展示了MySQL JDBC允许的跨类型相互转换。</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:center\">这些mysql数据类型</th>\r\n<th style=\"text-align:center\">总是可以转换为这些java类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:center\">CHAR, VARCHAR, BLOB, TEXT, ENUM, and SET</td>\r\n<td style=\"text-align:center\">java.lang.String, java.io.InputStream, java.io.Reader, java.sql.Blob, java.sql.Clob</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">FLOAT, REAL, DOUBLE PRECISION, NUMERIC, DECIMAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT</td>\r\n<td style=\"text-align:center\">java.lang.String, java.lang.Short, java.lang.Integer, java.lang.Long, java.lang.Double, java.math.BigDecimal</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">DATE, TIME, DATETIME, TIMESTAMP</td>\r\n<td style=\"text-align:center\">java.lang.String, java.sql.Date, java.sql.Timestamp</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<blockquote>\r\n<h2>注意</h2>\r\n</blockquote>\r\n<p>如果选择的Java数值数据类型的精度或容量低于要转换/来自的MySQL数据类型，则可能会出现舍入，溢出或精度丢失。</p>\r\n<p>MySQL Connector / J在处理MySQL数据类型和Java数据类型之间的转换方式方面是灵活的。</p>\r\n<p>在一般情况下，任何MySQL数据类型可以转换为一个 java.lang.String，任何数值类型可以转换为任意的Java数字类型的，虽然可能会出现舍入，溢出或精度损失。</p>\r\n<h3>参考建议</h3>\r\n<p><a href=\"https://link.jianshu.com?t=https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-type-conversions.html\" target=\"_blank\" rel=\"nofollow\">Java, JDBC and MySQL Types</a><br>\r\n<a href=\"https://link.jianshu.com?t=http://www.cnblogs.com/sunzhenchao/archive/2013/04/09/3009431.html\" target=\"_blank\" rel=\"nofollow\">Mybatis源代码分析之类型转换</a></p>', '2019-01-10 19:48:19', '2019-01-19 19:48:30');
INSERT INTO `t_blog` VALUES ('4', '全面掌控：读透这篇文章，你就基本搞定了Redis数据库了', '简单来说 Redis 就是一个数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的，所以存写速度非常快，因此 Redis 被广泛应用于缓存方向。\r\n\r\n另外，Redis 也经常用来做分布式锁。Redis 提供了多种数据类型来支持不同的业务场景。', 'spring', 'http://pknhrkp8l.bkt.clouddn.com/login.jpg', '0', '<p>简单来说 Redis 就是一个数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的，所以存写速度非常快，因此 Redis 被广泛应用于缓存方向。</p><p>另外，Redis 也经常用来做分布式锁。Redis 提供了多种数据类型来支持不同的业务场景。</p><p>除此之外，Redis 支持事务 、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p><p>本文将从以下几个方面全面解读 Redis：</p><p>为什么要用 Redis / 为什么要用缓存</p><p>为什么要用 Redis 而不用 map/guava 做缓存</p><p>Redis 和 Memcached 的区别</p><p>Redis 常见数据结构以及使用场景分析</p><p>Redis 设置过期时间</p><p>Redis 内存淘汰机制</p><p>Redis 持久化机制（怎么保证 Redis 挂掉之后再重启数据可以进行恢复）</p><p>Redis 事务</p><p>缓存雪崩和缓存穿透问题解决方案</p><p>如何解决 Redis 的并发竞争 Key 问题</p><p>如何保证缓存与数据库双写时的数据一致性</p><p>为什么要用 Redis / 为什么要用缓存？  主要从“高性能”和“高并发”这两点来看待这个问题。</p><h2>高性能</h2><div class=\"image-package\">\r\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 515px;\">\r\n<div class=\"image-container-fill\" style=\"padding-bottom: 57.74%;\"></div>\r\n<div class=\"image-view\" data-width=\"892\" data-height=\"515\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/13553988-b0f21fcbfddcbdaf.png\" data-original-width=\"892\" data-original-height=\"515\" data-original-format=\"image/png\" data-original-filesize=\"123558\"></div>\r\n</div>\r\n<div class=\"image-caption\"></div>\r\n</div><p>\r\n\r\n假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变了之后，同步改变缓存中相应的数据即可！\r\n\r\n</p><h2>高并发</h2><p><br></p><div class=\"image-package\">\r\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 615px;\">\r\n<div class=\"image-container-fill\" style=\"padding-bottom: 73.04%;\"></div>\r\n<div class=\"image-view\" data-width=\"842\" data-height=\"615\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/13553988-386f5a47d359d6c3.png\" data-original-width=\"842\" data-original-height=\"615\" data-original-format=\"image/png\" data-original-filesize=\"108867\"></div>\r\n</div>\r\n<div class=\"image-caption\"></div>\r\n</div><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p>为什么要用 Redis 而不用 map/guava 做缓存</p><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 JVM 的销毁而结束。</p><p>并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 Redis 或 Memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。</p><p>缺点是需要保持 Redis 或 Memcached 服务的高可用，整个程序架构上较为复杂。</p><p>Redis 和 Memcached 的区别</p><p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！</p><p>对于 Redis 和 Memcached 我总结了下面四点：</p><p><b>Redis 支持更丰富的数据类型（支持更复杂的应用场景）：</b>Redis 不仅仅支持简单的 K/V 类型的数据，同时还提供 list、set、zset、hash 等数据结构的存储。Memcache 支持简单的数据类型 String。</p><p><b>Redis 支持数据的持久化，</b>可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。</p><p><b>集群模式：</b>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 Cluster 模式的。</p><p><b>Memcached 是多线程，</b>非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</p><p>来自网络上的一张对比图，这里分享给大家：</p><p><br></p><div class=\"image-package\">\r\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 550px;\">\r\n<div class=\"image-container-fill\" style=\"padding-bottom: 61.94%;\"></div>\r\n<div class=\"image-view\" data-width=\"888\" data-height=\"550\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/13553988-44539f054f2daa1a.png\" data-original-width=\"888\" data-original-height=\"550\" data-original-format=\"image/png\" data-original-filesize=\"220427\"></div>\r\n</div>\r\n<div class=\"image-caption\"></div>\r\n</div><p>Redis 常见数据结构以及使用场景分析</p><p><b>String</b></p><p>常用命令：set、get、decr、incr、mget 等。</p><p>String 数据结构是简单的 Key-Value 类型，Value 其实不仅可以是 String，也可以是数字。常规 Key-Value 缓存应用；常规计数：微博数，粉丝数等。</p><p><b>Hash</b></p><p>常用命令： hget、hset、hgetall 等。</p><p>Hash 是一个 String 类型的 Field 和 Value 的映射表，Hash 特别适合用于存储对象。</p><p>后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。比如我们可以 Hash 数据结构来存储用户信息，商品信息等等。</p><p>比如下面我就用 Hash 类型存放了我本人的一些信息：</p><p>key=JavaUser293847</p><p>value={</p><p>“id”: 1,</p><p>“name”: “SnailClimb”,</p><p>“age”: 22,</p><p>“location”: “Wuhan, Hubei”</p><p>}</p><p><b>List</b></p><p>常用命令：lpush、rpush、lpop、rpop、lrange 等。</p><p>List 就是链表，Redis List 的应用场景非常多，也是 Redis 最重要的数据结构之一。</p><p>比如微博的关注列表，粉丝列表，消息列表等功能都可以用 Redis 的 List 结构来实现。</p><p>Redis List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 List 实现分页查询。</p><p>这是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p><p><b>Set</b></p><p>常用命令：sadd、spop、smembers、sunion 等。</p><p>Set 对外提供的功能与 List 类似是一个列表的功能，特殊之处在于 Set 是可以自动排重的。</p><p>当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择。</p><p>并且 Set 提供了判断某个成员是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。你可以基于 Set 轻易实现交集、并集、差集的操作。</p><p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。</p><p>这个过程也就是求交集的过程，具体命令如下：</p><p>sinterstore key1 key2 key3 将交集存在key1内</p><p><b>Sorted Set</b></p><p>常用命令：zadd、zrange、zrem、zcard 等。</p><p>和 Set 相比，Sorted Set 增加了一个权重参数 Score，使得集合中的元素能够按 Score 进行有序排列。</p><p>举例：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p><p>Redis 设置过期时间</p><p>Redis 中有个设置过期时间的功能，即对存储在 Redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。</p><p>如我们一般项目中的 Token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p><p>我们 Set Key 的时候，都可以给一个 Expire Time，就是过期时间，通过过期时间我们可以指定这个 Key 可以存活的时间。</p><p>如果你设置了一批 Key 只能存活 1 个小时，那么接下来 1 小时后，Redis 是怎么对这批 Key 进行删除的？</p><p>答案是：定期删除+惰性删除。通过名字大概就能猜出这两个删除方式的意思了：</p><p><b>定期删除：</b>Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 Key，检查其是否过期，如果过期就删除。</p><p>注意这里是随机抽取的。为什么要随机呢？你想一想假如 Redis 存了几十万个 Key ，每隔 100ms 就遍历所有的设置过期时间的 Key 的话，就会给 CPU 带来很大的负载！</p><p><b>惰性删除 ：</b>定期删除可能会导致很多过期 Key 到了时间并没有被删除掉。所以就有了惰性删除。</p><p>假如你的过期 Key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 Key，才会被 Redis 给删除掉。这就是所谓的惰性删除，也是够懒的哈！</p><p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 Key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？</p><p>如果大量过期 Key 堆积在内存里，导致 Redis 内存块耗尽了。怎么解决这个问题呢？</p><p>Redis 内存淘汰机制</p><p>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</p><p>Redis 配置文件 redis.conf 中有相关注释，我这里就不贴了，大家可以自行查阅或者通过这个网址查看：http://download.redis.io/redis-stable/redis.conf</p><p>Redis 提供 6 种数据淘汰策略：</p><p><b>volatile-lru：</b>从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。</p><p><b>volatile-ttl：</b>从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。</p><p><b>volatile-random：</b>从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。</p><p><b>allkeys-lru：</b>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）。</p><p><b>allkeys-random：</b>从数据集（server.db[i].dict）中任意选择数据淘汰。</p><p><b>no-enviction：</b>禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</p><p>Redis 持久化机制</p><p>怎么保证 Redis 挂掉之后再重启数据可以进行恢复？很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面。</p><p>大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。</p><p>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file，AOF）。</p><p>这两种方法各有千秋，下面我会详细讲这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p><p><b>快照（snapshotting）持久化（RDB</b>）</p><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。</p><p>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 redis.conf 配置文件中默认有此下配置：</p><p>save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</p><p>save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</p><p>save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</p><p><b>AOF（append-only file）持久化</b></p><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。</p><p>默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><p>appendonly yes</p><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><p>appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</p><p>appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘</p><p>appendfsync no #让操作系统决定何时进行同步</p><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。</p><p>而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><b>Redis 4.0 对于持久化机制的优化</b></p><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。</p><p>这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。</p><p>当然缺点也是有的，AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><p><b>补充内容：AOF 重写</b></p><p>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任伺读入、分析或者写入操作。</p><p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。</p><p>当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。</p><p>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><p>Redis 事务</p><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。</p><p>事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制。</p><p>并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。</p><p>在 Redis 中，事务总是具有原子性（Atomicity)、一致性(Consistency)和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p><p>缓存雪崩和缓存穿透问题解决方案</p><p><b>缓存雪崩</b></p><p><b>简介：</b>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><br></p><div class=\"image-package\">\r\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 691px;\">\r\n<div class=\"image-container-fill\" style=\"padding-bottom: 57.92%;\"></div>\r\n<div class=\"image-view\" data-width=\"1193\" data-height=\"691\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/13553988-976d1462535260ce.png\" data-original-width=\"1193\" data-original-height=\"691\" data-original-format=\"image/png\" data-original-filesize=\"265659\"></div>\r\n</div>\r\n<div class=\"image-caption\"></div>\r\n</div><p><br></p><div class=\"image-package\">\r\n<div class=\"image-container\" style=\"max-width: 700px; max-height: 259px;\">\r\n<div class=\"image-container-fill\" style=\"padding-bottom: 28.43%;\"></div>\r\n<div class=\"image-view\" data-width=\"911\" data-height=\"259\"><img data-original-src=\"//upload-images.jianshu.io/upload_images/13553988-4be070070e7546f7.png\" data-original-width=\"911\" data-original-height=\"259\" data-original-format=\"image/png\" data-original-filesize=\"54192\"></div>\r\n</div>\r\n<div class=\"image-caption\"></div>\r\n</div><p><b>缓存穿透</b></p><p><b>简介：</b>一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><b>解决办法：</b>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中。</p><p>一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p><p>另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><p>如何解决 Redis 的并发竞争 Key 问题</p><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 Key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p><b>推荐一种方案：</b>分布式锁（ZooKeeper 和 Redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于 ZooKeeper 临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在 ZooKeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。</p><p>判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。</p><p>同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是以可靠性为主。所以首推 ZooKeeper。</p><p>如何保证缓存与数据库双写时的数据一致性</p><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况。</p><p>最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。</p><p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>', '2019-01-10 19:48:19', '2019-01-19 19:48:30');
